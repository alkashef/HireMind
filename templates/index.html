<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Folder Browser</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}" />
  </head>
  <body>
    <div class="tabs" role="tablist" aria-label="Sections">
      <button id="tabApplicants" class="tab-btn active" role="tab" aria-selected="true" aria-controls="paneApplicants">Applicants</button>
      <button id="tabRoles" class="tab-btn" role="tab" aria-selected="false" aria-controls="paneRoles">Roles</button>
    </div>

    <div id="paneApplicants" class="tab-pane active" role="tabpanel" aria-labelledby="tabApplicants">
  <label class="folder-label" for="folderPath">CVs Repository:</label>
      <div class="row">
        <div class="path-box">
          <input id="folderPath" type="text" readonly placeholder="No folder selected" />
        </div>
        <button id="browseBtn">Browseâ€¦</button>
        <button id="refreshBtn" title="Refresh list">Refresh</button>
      </div>
      <div class="content-row">
        <div class="left-pane">
          <div id="list" class="list"></div>
          <div class="list-footer">
            <span id="fileCount" class="file-count"></span>
            <div class="actions">
              <button id="selectAllBtn" title="Select all files">Select All</button>
              <button id="extractBtn">Extract</button>
            </div>
          </div>
        </div>
        <div class="right-pane">
          <div class="table-wrap">
            <table id="extractTable" class="data-table" aria-label="Selected record details">
              <tbody></tbody>
            </table>
          </div>
        </div>
      </div>
    </div>

    <div id="paneRoles" class="tab-pane" role="tabpanel" aria-labelledby="tabRoles">
      <div class="muted">Roles tab (placeholder)</div>
    </div>

  <script src="{{ url_for('static', filename='status.js') }}"></script>
  <script>
      // Verbose status + progress helpers
      let statusTimer = null;
      let statusStartTs = null;
      function setStatus(msg) { const sb = document.getElementById('statusBar'); if (sb) sb.value = msg || ''; }
      function startStatusProgress(prefix) {
        stopStatusProgress();
        statusStartTs = Date.now();
        setStatus(`${prefix} (0.0s)...`);
        statusTimer = setInterval(() => {
          const s = ((Date.now() - statusStartTs) / 1000).toFixed(1);
          setStatus(`${prefix} (${s}s)...`);
        }, 200);
      }
      function stopStatusProgress(finalMsg) {
        if (statusTimer) { clearInterval(statusTimer); statusTimer = null; }
        if (typeof finalMsg === 'string') setStatus(finalMsg);
      }
      function setUIBusy(busy) {
        ['browseBtn','refreshBtn','selectAllBtn','extractBtn'].forEach(id => {
          const el = document.getElementById(id);
          if (el) el.disabled = !!busy;
        });
      }
      async function fetchJSON(url) {
        const r = await fetch(url);
        if (!r.ok) throw new Error(`HTTP ${r.status}`);
        return await r.json();
      }

      const selected = new Set();
      let lastSelectedIndex = null; // track last clicked index for shift-range

      let duplicateCount = 0;
      function updateFooter(total) {
        const countEl = document.getElementById('fileCount');
        const totalNum = Number(total) || 0;
        const selNum = selected.size || 0;
        const dupText = duplicateCount > 0 ? ` | ${duplicateCount} duplicates found` : '';
        countEl.textContent = `${totalNum} file${totalNum === 1 ? '' : 's'} | ${selNum} selected${dupText}`;
        if (selNum > 0) setStatus(`Selected ${selNum} file${selNum === 1 ? '' : 's'}.`);
      }

      let tableRows = [];

      function getSingleSelectedBasename() {
        if (selected.size !== 1) return null;
        const onlyPath = Array.from(selected)[0] || '';
        return onlyPath.toString().split(/[\\\\/]/).pop();
      }

      function renderDetailForSelection() {
        const tbody = document.querySelector('#extractTable tbody');
        const cvName = getSingleSelectedBasename();
        // Always render the table structure; populate values if available
        const rec = cvName ? tableRows.find(r => (r.cv || '') === cvName) : null;
        if (!rec && cvName) {
          if (window.setStatus) window.setStatus('Not extracted yet');
        }
        const pairs = [
          ['ID', (rec && rec.id) || ''],
          ['Timestamp', (rec && rec.timestamp) || ''],
          ['CV', (rec && rec.cv) || (cvName || '')],
          ['Full Name', (rec && rec.full_name) || ''],
        ];
        tbody.innerHTML = pairs.map(([h, v]) => `<tr><td>${h}</td><td>${v}</td></tr>`).join('');
      }

      async function refreshTable() {
        try {
          if (window.setStatus) window.setStatus('Loading extracted results...');
          const r = await fetch('/api/extract');
          const j = await r.json();
          tableRows = Array.isArray(j.rows) ? j.rows : [];
          renderDetailForSelection();
          if (window.setStatus) window.setStatus('Ready');
        } catch (e) {
          console.error('Failed to load table rows', e);
          if (window.setStatus) window.setStatus(`Error loading results: ${e.message || e}`);
        }
      }

      async function highlightDuplicates(files) {
        try {
          if (window.setStatus) window.setStatus('Computing duplicates...');
          const r = await fetch('/api/hashes', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ files }),
          });
          const j = await r.json();
          const dups = new Set((j.duplicates || []).map(String));
          duplicateCount = Number(j.duplicate_count || 0);
          document.querySelectorAll('#list .item').forEach(el => {
            const p = decodeURIComponent(el.getAttribute('data-path'));
            el.classList.toggle('duplicate', dups.has(p));
          });
        } catch (e) {
          console.error('Failed to compute duplicates', e);
          duplicateCount = 0;
        } finally {
          const items = Array.from(document.querySelectorAll('#list .item'));
          updateFooter(items.length);
          if (window.setStatus) window.setStatus('Ready');
        }
      }

      function renderList(folder, files) {
        const box = document.getElementById('list');
        document.getElementById('folderPath').value = folder || '';
        selected.clear();
        updateFooter(0);
        if (!folder) {
          box.innerHTML = '<div class="muted">No folder selected.</div>';
          updateFooter(0);
          return;
        }
        if (!files || files.length === 0) {
          box.innerHTML = `<div class="muted">No .pdf or .docx files in: ${folder}</div>`;
          updateFooter(0);
          return;
        }
          box.innerHTML = files.map((f, i) => {
            const name = (f || '').toString().split(/[\\\\/]/).pop();
            return `<div class="item" data-index="${i}" data-path="${encodeURIComponent(f)}">${name}</div>`;
          }).join('');
        updateFooter(files.length);
        // compute duplicate highlighting by content hash
        highlightDuplicates(files);

        // Attach click handlers for selection toggle (multi-select)
        const items = Array.from(box.querySelectorAll('.item'));
        const clearAll = () => {
          items.forEach(node => node.classList.remove('selected'));
          selected.clear();
        };
        const toggleOne = (node) => {
          const p = decodeURIComponent(node.getAttribute('data-path'));
          if (node.classList.contains('selected')) {
            node.classList.remove('selected');
            selected.delete(p);
          } else {
            node.classList.add('selected');
            selected.add(p);
          }
        };
        const selectOne = (node) => {
          clearAll();
          const p = decodeURIComponent(node.getAttribute('data-path'));
          node.classList.add('selected');
          selected.add(p);
        };
        const selectRange = (startIdx, endIdx) => {
          clearAll();
          const [a, b] = startIdx <= endIdx ? [startIdx, endIdx] : [endIdx, startIdx];
          for (let i = a; i <= b; i++) {
            const node = items[i];
            const p = decodeURIComponent(node.getAttribute('data-path'));
            node.classList.add('selected');
            selected.add(p);
          }
        };

        items.forEach(el => {
          el.addEventListener('click', (ev) => {
            const idx = Number(el.getAttribute('data-index'));
            if (ev.shiftKey && lastSelectedIndex !== null && !Number.isNaN(idx)) {
              selectRange(lastSelectedIndex, idx);
            } else if (ev.ctrlKey || ev.metaKey) {
              // toggle without clearing
              toggleOne(el);
            } else {
              // plain click -> single selection only
              selectOne(el);
            }
            lastSelectedIndex = idx;
            updateFooter(files.length);
            renderDetailForSelection();
          });
        });
      }

      async function loadDefault() {
        try {
          if (window.setStatus) window.setStatus('Loading folder...');
          const d = await fetchJSON('/api/list-files');
          renderList(d.folder, d.files);
          if (window.setStatus) window.setStatus('Ready');
        } catch (e) {
          console.error(e);
          if (window.setStatus) window.setStatus(`Error loading folder: ${e.message || e}`);
        }
      }

      document.getElementById('browseBtn').addEventListener('click', async () => {
        try {
          if (window.setStatus) window.setStatus('Opening folder picker...');
          const d = await fetchJSON('/api/pick-folder');
          renderList(d.folder, d.files);
          if (window.setStatus) window.setStatus('Ready');
        } catch (e) {
          console.error(e);
          if (window.setStatus) window.setStatus(`Error picking folder: ${e.message || e}`);
        }
      });

  document.getElementById('refreshBtn').addEventListener('click', () => { if (window.setStatus) window.setStatus('Refreshing...'); loadDefault(); });

      // Select All button -> select all items in the list
      document.getElementById('selectAllBtn').addEventListener('click', () => {
        const items = Array.from(document.querySelectorAll('#list .item'));
        items.forEach(el => {
          const p = decodeURIComponent(el.getAttribute('data-path'));
          el.classList.add('selected');
          selected.add(p);
        });
        updateFooter(items.length);
        renderDetailForSelection();
      });

      // Extract button handler -> call backend API (no alerts on success)
      document.getElementById('extractBtn').addEventListener('click', async () => {
        const picked = Array.from(selected);
        if (picked.length === 0) {
          // Keep a minimal UX hint for empty selection
          alert('Select one or more files to extract.');
          return;
        }
        try {
          if (window.setUIBusy) window.setUIBusy(true);
          if (window.startStatusProgress) window.startStatusProgress(`Extracting ${picked.length} file${picked.length === 1 ? '' : 's'}`);
          const r = await fetch('/api/extract', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ files: picked }),
          });
          const j = await r.json();
          if (!r.ok) throw new Error(j.error || 'Extraction failed');
          // silently refresh table; no message shown
          await refreshTable();
          // Unselect all items and update footer
          const items = Array.from(document.querySelectorAll('#list .item'));
          items.forEach(el => el.classList.remove('selected'));
          selected.clear();
          updateFooter(items.length);
          renderDetailForSelection();
          // Update status bar with any errors summary
          const errs = Array.isArray(j.errors) ? j.errors : [];
          if (errs.length) {
            if (window.stopStatusProgress) window.stopStatusProgress(`Extraction completed with ${errs.length} error${errs.length === 1 ? '' : 's'}; saved ${j.saved}.`);
          } else {
            if (window.stopStatusProgress) window.stopStatusProgress(`Extraction completed successfully; saved ${j.saved}.`);
          }
        } catch (e) {
          console.error(e);
          // no user alert on error per requirement
          if (window.stopStatusProgress) window.stopStatusProgress(`Error: ${e.message || e}`);
        } finally {
          if (window.setUIBusy) window.setUIBusy(false);
        }
      });

  if (window.setStatus) window.setStatus('Initializing...');
  loadDefault();
  refreshTable();
  if (window.setStatus) window.setStatus('Ready');

      // Tabs logic
      const tabApplicants = document.getElementById('tabApplicants');
      const tabRoles = document.getElementById('tabRoles');
      const paneApplicants = document.getElementById('paneApplicants');
      const paneRoles = document.getElementById('paneRoles');

      function activate(tab) {
        const isApplicants = tab === 'applicants';
        tabApplicants.classList.toggle('active', isApplicants);
        tabRoles.classList.toggle('active', !isApplicants);
        tabApplicants.setAttribute('aria-selected', String(isApplicants));
        tabRoles.setAttribute('aria-selected', String(!isApplicants));
        paneApplicants.classList.toggle('active', isApplicants);
        paneRoles.classList.toggle('active', !isApplicants);
      }

      tabApplicants.addEventListener('click', () => activate('applicants'));
      tabRoles.addEventListener('click', () => activate('roles'));
    </script>
    <textarea id="statusBar" class="status-bar" rows="1" readonly placeholder="Status..."></textarea>
  </body>
  </html>
